#!/usr/bin/env php
<?php

/**
 * This is a wrapper around composer that installs or updates it
 * and delegates call to it as if composer itself was called.
 *
 * If it breaks, check out newer version or report an issue at
 * https://github.com/kamazee/composer-wrapper
 *
 * @version 1.1.0
 */
if (!class_exists('ComposerWrapper')) {
    class ComposerWrapperParams {
        /**
         * @var int|false
         */
        private $forceMajorVersion = false;
        /**
         * @var string
         */
        private $updateFreq = '7 days';
        /**
         * @var string
         */
        private $composerDir = __DIR__;
        /**
         * @var string
         */
        private $wrapperDir = __DIR__;

        public function __construct($wrapperDir = null)
        {
            if (null !== $wrapperDir) {
                $this->wrapperDir = $wrapperDir;
            }
        }

        public function loadReal()
        {
            $this->loadComposerJson();
            // env variables have the highest priority
            $this->loadEnv();
        }


        private function loadEnv()
        {
            if ( false !== $value = \getenv('COMPOSER_UPDATE_FREQ')) {
                $this->setUpdateFreq($value);
            }
            if ( false !== $value = \getenv('COMPOSER_FORCE_MAJOR_VERSION')) {
                $this->setForceMajorVersion($value);
            }
            if ( false !== $value = \getenv('COMPOSER_DIR')) {
                $this->setComposerDir($value);
            }
        }

        private function loadComposerJson()
        {
            $file = $this->wrapperDir . '/composer.json';
            // It is the same logic of reading composer.json as is in the Composer
            if (!is_file($file) || !is_readable($file) || !is_array($composer = json_decode(file_get_contents($file),                                                                                        true))) {
                return;
            }

            if (empty($composer['config']['wrapper'])) {
                return;
            }

            $wrapper = $composer['config']['wrapper'];
            if (!empty($wrapper['update-freq'])) {
                $this->setUpdateFreq($wrapper['update-freq']);
            }
            if (!empty($wrapper['major-version'])) {
                $this->setForceMajorVersion($wrapper['major-version']);
            }
            if (!empty($wrapper['composer-dir'])) {
                $this->setComposerDir($wrapper['composer-dir']);
            }
        }

        /**
         * @return bool
         */
        public function getForceMajorVersion()
        {
            return $this->forceMajorVersion;
        }

        /**
         * @param false|int $version
         */
        public function setForceMajorVersion($version)
        {
            $allowed = array("1", 1, "2", 2);
            if (false === in_array($version, $allowed, true)) {
                throw new Exception(
                    sprintf(
                        'Wrong major version is requested: "%s"; only 1 and 2 are supported in string or integer format',
                        $version
                    )
                );
            }
            $this->forceMajorVersion = (int) $version;
        }

        /**
         * @return string
         */
        public function getUpdateFreq()
        {

            return $this->updateFreq;
        }

        /**
         * @param string $updateFreq
         */
        public function setUpdateFreq($updateFreq)
        {
            // DateTime $modifier validation. Taken from https://stackoverflow.com/a/34899724/2165434
            $d = new DateTime();
            $isValid = @$d->modify($updateFreq);

            if ($isValid === false) {
                throw new \Exception(sprintf('Wrong update frequency is requested: %s; should be valid DateTime modifier (follow %s for the help)', $updateFreq,'https://www.php.net/manual/en/datetime.modify.php'));
            }

            $this->updateFreq = (string) $updateFreq;
        }

        /**
         * @return string
         */
        public function getComposerDir()
        {
            return $this->composerDir;
        }

        /**
         * @param string $composerDir
         */
        public function setComposerDir($composerDir)
        {
            if (!is_dir($composerDir) || !is_writable($composerDir)) {
                throw new \Exception(sprintf(
                        "Wrong composer dir is requested: %s; argument is not a dir or is not writable dir",
                        $composerDir));
            }

            $this->composerDir = (string) $composerDir;
        }

    }
    class ComposerWrapper
    {
        const COMPOSER_HASHBANG = "#!/usr/bin/env php\n";
        const EXPECTED_INSTALLER_CHECKSUM_URL = 'https://composer.github.io/installer.sig';
        const INSTALLER_URL = 'https://getcomposer.org/installer';
        const INSTALLER_FILE = 'composer-setup.php';
        const EXIT_CODE_SUCCESS = 0;
        const EXIT_CODE_ERROR_DOWNLOADING_CHECKSUM = 1;
        const MSG_ERROR_DOWNLOADING_CHECKSUM = 'Error when downloading composer installer checksum';
        const EXIT_CODE_ERROR_DOWNLOADING_INSTALLER = 2;
        const MSG_ERROR_DOWNLOADING_INSTALLER = 'Error when downloading composer installer';
        const EXIT_CODE_ERROR_INSTALLER_CHECKSUM_MISMATCH = 3;
        const MSG_ERROR_INSTALLER_CHECKSUM_MISMATCH = 'Failed to install composer: checksum of composer installer does not match expected checksum';
        const EXIT_CODE_ERROR_WHEN_INSTALLING = 4;
        const MSG_ERROR_WHEN_INSTALLING = 'Error when running composer installer';
        const EXIT_CODE_ERROR_MAKING_EXECUTABLE = 5;
        const MSG_SELF_UPDATE_FAILED = 'composer self-update failed; proceeding with existing';
        const EXIT_CODE_COMPOSER_EXCEPTION = 6;

        /**
         * @var ComposerWrapperParams
         */
        protected $params;

        public function __construct()
        {
            $this->params = new ComposerWrapperParams();
        }

        protected function file_get_contents()
        {
            return \call_user_func_array('file_get_contents', func_get_args());
        }

        protected function copy()
        {
            return \call_user_func_array('copy', \func_get_args());
        }

        protected function passthru($command, &$exitCode)
        {
            \passthru($command, $exitCode);
        }

        protected function unlink()
        {
            return \call_user_func_array('unlink', \func_get_args());
        }

        protected function touch()
        {
            return \call_user_func_array('touch', \func_get_args());
        }

        protected function supportsForceVersionFlag($filename, $version)
        {
            try {
                $output = $this->getCliCallOutput(
                    \sprintf(
                        '%s %s --no-ansi help self-update',
                        \escapeshellarg($this->getPhpBinary()),
                        \escapeshellarg($filename)
                    )
                );
            } catch (Exception $e) {
                throw new \Exception(
                    'Error when trying to check support for forcing ' .
                    'specific major version on self-update',
                    0,
                    $e
                );
            }

            foreach ($output as $line) {
                $line = trim($line);
                if (false !== strpos($line, "--$version ")) {
                    return true;
                }
            }

            return false;
        }

        protected function getCliCallOutput($command)
        {
            $output = array();
            \exec($command, $output, $exitCode);
            if (0 !== $exitCode) {
                throw new \Exception(
                    "Can't get current composer version" .
                    "Exit code: $exitCode, output: " . \implode(\PHP_EOL, $output)
                );
            }

            return $output;
        }

        public function getPhpBinary()
        {
            if (defined('PHP_BINARY')) {
                return \PHP_BINARY;
            }

            return \PHP_BINDIR . '/php';
        }

        public function installComposer($dir)
        {
            $installerPathName = $dir . DIRECTORY_SEPARATOR . static::INSTALLER_FILE;
            if (!$this->copy(static::INSTALLER_URL, $installerPathName)) {
                throw new Exception(
                    self::MSG_ERROR_DOWNLOADING_INSTALLER,
                    self::EXIT_CODE_ERROR_DOWNLOADING_INSTALLER
                );
            }

            $this->verifyChecksum($installerPathName);

            \passthru(
                \sprintf(
                    '%s %s --install-dir=%s',
                    \escapeshellarg($this->getPhpBinary()),
                    \escapeshellarg($installerPathName),
                    \escapeshellarg($dir)
                ),
                $exitCode
            );

            $this->unlink($installerPathName);

            if (self::EXIT_CODE_SUCCESS !== $exitCode) {
                throw new Exception(
                    self::MSG_ERROR_WHEN_INSTALLING,
                    self::EXIT_CODE_ERROR_WHEN_INSTALLING
                );
            }

            unset($exitCode);
        }


        protected function verifyChecksum($installerPathName)
        {
            $expectedInstallerHash = $this->file_get_contents(static::EXPECTED_INSTALLER_CHECKSUM_URL);
            if (empty($expectedInstallerHash)) {
                throw new Exception(
                    self::MSG_ERROR_DOWNLOADING_CHECKSUM,
                    self::EXIT_CODE_ERROR_DOWNLOADING_CHECKSUM
                );
            }

            $expectedInstallerHash = trim($expectedInstallerHash);

            $actualInstallerHash = \hash_file('sha384', $installerPathName);
            if ($expectedInstallerHash !== $actualInstallerHash) {
                $this->unlink($installerPathName);

                throw new Exception(
                    self::MSG_ERROR_INSTALLER_CHECKSUM_MISMATCH,
                    self::EXIT_CODE_ERROR_INSTALLER_CHECKSUM_MISMATCH
                );
            }
        }

        protected function ensureInstalled($filename)
        {
            if (\file_exists($filename)) {
                return;
            }

            $this->installComposer(dirname($filename));
        }

        protected function ensureExecutable($filename)
        {
            if (!\file_exists($filename)) {
                throw new Exception("Can't make $filename executable: it doesn't exist");
            }

            if (\is_executable($filename)) {
                return;
            }

            $currentMode = \fileperms($filename);
            $executablePermissions = $currentMode | 0111;
            if (false === \chmod($filename, $executablePermissions)) {
                throw new Exception(
                    "Can't make $filename executable",
                    self::EXIT_CODE_ERROR_MAKING_EXECUTABLE
                );
            }
        }

        protected function isUpToDate($filename)
        {
            $composerUpdateFrequency = $this->params->getUpdateFreq();

            $now = new \DateTime('now', new DateTimeZone('UTC'));
            $nowClone = clone $now;
            $nowPlusFrequency = $nowClone->modify($composerUpdateFrequency);

            if ($nowPlusFrequency < $now) {
                $this->showError('Composer update frequency must not be negative');
            }

            $mtimeTimestamp = \filemtime($filename);
            $mtimePlusFrequency = \DateTime::createFromFormat(
                'U',
                $mtimeTimestamp,
                new \DateTimeZone('UTC')
            )
                ->modify($composerUpdateFrequency);

            return $mtimePlusFrequency > $now;
        }

        protected function selfUpdate($filename)
        {
            $selfUpdateCommand = \sprintf('%s self-update', \escapeshellarg($filename));
            $selfUpdateCommand .= $this->getSelfUpdateFlags($filename);
            $this->passthru(
                $selfUpdateCommand,
                $exitCode
            );

            // composer exits both when self-update downloaded a new version
            // and when no new version was available (and everything went OK)
            if (self::EXIT_CODE_SUCCESS === $exitCode) {
                $this->touch($filename);
            } else {
                // if self-update failed, next call should try it again, hence no touch()
                $this->showError(self::MSG_SELF_UPDATE_FAILED);
            }
        }

        private function getSelfUpdateFlags($filename)
        {
            $forceVersionRequested = $this->params->getForceMajorVersion();
            $flags = '';
            if (false === $forceVersionRequested) {
                return $flags;
            }

            if ($this->supportsForceVersionFlag(
                $filename,
                $forceVersionRequested
            )) {
                $flags .= " --$forceVersionRequested";
            } elseif (1 == $forceVersionRequested) {
                // 1.10.5 supports flags, so should be a good intermediate version
                $flags .= ' 1.10.5';
            } else {
                $this->showError(
                    "Forcing version $forceVersionRequested is requested but current composer version doesn't support --$forceVersionRequested flag, so nothing will be forced."
                );
            }

            return $flags;
        }

        protected function ensureUpToDate($filename)
        {
            if (!\file_exists($filename)) {
                throw new \Exception("Can't run composer self-update for $filename: it doesn't exist");
            }

            if ($this->isUpToDate($filename)) {
                return;
            }

            $this->selfUpdate($filename);
        }

        protected function delegate($filename)
        {
            \ob_start(
                function ($buffer) {
                    if (0 === \strpos($buffer, ComposerWrapper::COMPOSER_HASHBANG)) {
                        return \substr($buffer, \strlen(ComposerWrapper::COMPOSER_HASHBANG));
                    }

                    return false;
                }
            );

            try {
                require $filename;
            } catch (Exception $e) {
                \ob_end_flush();
                throw new Exception(
                    "Composer exception was thrown: {$e->getMessage()}",
                    self::EXIT_CODE_COMPOSER_EXCEPTION,
                    $e
                );
            }

            \ob_end_flush();
        }

        public function showError($text)
        {
            \fwrite(STDERR, $text . "\n");
        }

        /**
         * @throws Exception
         */
        public function run()
        {
            $this->params->loadReal();
            $composerPathName = "{$this->params->getComposerDir()}/composer.phar";

            $this->ensureInstalled($composerPathName);
            $this->ensureExecutable($composerPathName);
            $this->ensureUpToDate($composerPathName);
            $this->delegate($composerPathName);
        }
    }
}

if ('cli' === \PHP_SAPI && @\realpath($_SERVER['argv'][0]) === __FILE__) {
    $runner = new ComposerWrapper();

    try {
        $runner->run();
    } catch (Exception $e) {
        $runner->showError('ERROR: ' . $e->getMessage());
        exit($e->getCode());
    }
}
